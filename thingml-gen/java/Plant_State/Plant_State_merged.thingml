thing MQTTDriver includes GeneralMsg {
	required port to_pim {
		sends messages
	}
	provided port from_pim {
		receives messages
	}
	provided port MQTT {
		sends messages receives messages
	}
	statechart behaviorMQTTDriver init Idle {
		state Idle {
			transition -> Idle
			event messages : MQTT?messages
			action do
				to_pim!messages(messages.section_id, messages.msg_type, messages.msg_txt, messages.value)
			end
			transition -> Idle
			event messages : from_pim?messages
			action do
				MQTT!messages(messages.section_id, messages.msg_type, messages.msg_txt, messages.value)
			end
		}
	}
}
thing PIM includes GeneralMsg , TimerMsgs {
	required port timer {
		sends timer_start sends timer_cancel receives timer_timeout
	}
	required port to_psm {
		sends reply
	}
	provided port from_psm {
		receives messages
	}
	property number_of_sections : Integer = 2
	property current_plant_state : String
	property current_side_camera_height : Double
	property current_light_green_pixel_count : Double
	property current_green_pixel_count : Double
	property current_dark_green_pixel_count : Double
	property current_red_pixel_count : Double
	property current_white_pixel_count : Double
	property current_yellow_pixel_count : Double
	property section_id : Integer = 0
	property fruit_threshhold : Double = 10
	statechart Plant_State init InitSections {
		state InitSections {
			on entry do
				section_id = section_id + 1
				println ("Initializing Section with ID: " + section_id)
				fork Section
			end
			transition -> InitSections guard section_id < number_of_sections
			transition -> InitCompleted guard section_id == number_of_sections
		}
		final state InitCompleted {
		}
		session Section init Running {
			composite state Running init Germination keeps history {
				state Germination {
					on entry do
						timer!timer_start(10 * 24 * 60 * 60 * 1000)
					end
					on exit do
						timer!timer_cancel()
					end
					transition -> Dying_During_Germination_or_Seedling
					event timeout : timer?timer_timeout
					guard timeout.id == section_id
					action do
						current_plant_state = "Dying_During_Germination"
						to_psm!reply(section_id - 1, current_plant_state)
					end
					transition -> Seedling
					event messages : from_psm?messages
					guard messages.msg_type == "side_camera_height" or messages.msg_type == "light_green_pixel_count" or messages.msg_type == "green_pixel_count" or messages.msg_type == "dark_green_pixel_count" and messages.section_id == section_id and messages.value > 0
					action do
						if (messages.msg_type == "side_camera_height") do
							current_side_camera_height = messages.value
						end
						if (messages.msg_type == "light_green_pixel_count") do
							current_light_green_pixel_count = messages.value
						end
						if (messages.msg_type == "green_pixel_count") do
							current_green_pixel_count = messages.value
						end
						if (messages.msg_type == "dark_green_pixel_count") do
							current_dark_green_pixel_count = messages.value
						end
						current_plant_state[messages.section_id] = "Seedling"
						to_psm!reply(section_id - 1, current_plant_state)
					end
				}
				state Seedling {
					on entry do
						timer!timer_start(14 * 24 * 60 * 60 * 1000)
					end
					on exit do
						timer!timer_cancel()
					end
					transition -> Dying_During_Germination_or_Seedling
					event timeout : timer?timer_timeout
					guard timeout.id == section_id
					action do
						current_plant_state = "Dying_During_Germination"
						to_psm!reply(section_id - 1, current_plant_state)
					end
					transition -> Growing
					event messages : from_psm?messages
					guard messages.msg_type == "light_green_pixel_count" or messages.msg_type == "green_pixel_count" or messages.msg_type == "dark_green_pixel_count" and messages.section_id == section_id and messages.value > 0
					action do
						if (messages.msg_type == "light_green_pixel_count") do
							current_light_green_pixel_count = messages.value
						end
						if (messages.msg_type == "green_pixel_count") do
							current_green_pixel_count = messages.value
						end
						if (messages.msg_type == "dark_green_pixel_count") do
							current_dark_green_pixel_count = messages.value
						end
						current_plant_state = "Growing"
						to_psm!reply(section_id - 1, current_plant_state)
					end
				}
				state Growing {
					transition -> Dying_During_Growing_or_Fruiting
					event messages : from_psm?messages
					guard messages.msg_type == "green_pixel_count" and messages.section_id == section_id and messages.value < current_light_green_pixel_count
					action do
						current_light_green_pixel_count = messages.value
						current_plant_state = "Dying_During_Growing"
						to_psm!reply(section_id - 1, current_plant_state)
					end
					transition -> Fruting
					event messages : from_psm?messages
					guard messages.section_id == section_id and messages.msg_type == "red_pixel_count" or messages.msg_type == "yellow_pixel_count" or messages.msg_type == "white_pixel_count" and messages.value > fruit_threshhold and current_dark_green_pixel_count > current_green_pixel_count
					action do
						if (messages.msg_type == "red_pixel_count") do
							current_red_pixel_count = messages.value
						end
						if (messages.msg_type == "yellow_pixel_count") do
							current_yellow_pixel_count = messages.value
						end
						if (messages.msg_type == "white_pixel_count") do
							current_white_pixel_count = messages.value
						end
						current_plant_state = "Fruiting"
						to_psm!reply(section_id - 1, current_plant_state)
					end
				}
				state Fruting {
					transition -> Dying_During_Growing_or_Fruiting
					event messages : from_psm?messages
					guard messages.section_id == section_id and messages.msg_type == "red_pixel_count" and messages.value < current_red_pixel_count
					action do
						current_red_pixel_count = messages.value
						current_plant_state = "Dying_During_Fruting"
						to_psm!reply(section_id - 1, current_plant_state)
					end
				}
				state Dying_During_Germination_or_Seedling {
					transition -> Seedling
					event messages : from_psm?messages
					guard messages.msg_type == "side_camera_height" or messages.msg_type == "light_green_pixel_count" or messages.msg_type == "green_pixel_count" or messages.msg_type == "dark_green_pixel_count" and messages.section_id == section_id and messages.value > 0
					action do
						if (messages.msg_type == "side_camera_height") do
							current_side_camera_height = messages.value
						end
						if (messages.msg_type == "light_green_pixel_count") do
							current_light_green_pixel_count = messages.value
						end
						if (messages.msg_type == "green_pixel_count") do
							current_green_pixel_count = messages.value
						end
						if (messages.msg_type == "dark_green_pixel_count") do
							current_dark_green_pixel_count = messages.value
						end
						current_plant_state[messages.section_id] = "Seedling"
						to_psm!reply(section_id - 1, current_plant_state)
					end
				}
				state Dying_During_Growing_or_Fruiting {
					transition -> Growing
					event messages : from_psm?messages
					guard messages.section_id == section_id and messages.msg_type == "green_pixel_count" and messages.value < current_green_pixel_count
					action do
						current_green_pixel_count = messages.value
						current_plant_state = "Growing"
						to_psm!reply(section_id - 1, current_plant_state)
					end
				}
			}
		}
	}
}
object JTimerTask @java_type "java.util.TimerTask"
object JTimer @java_type "java.util.Timer"
thing TimerJava includes Timer @pim "Timer" @platform "java" {
	property timer : JTimer
	property timer_task : JTimerTask
	function startTimer(delay : Integer) do
		timer = `new java.util.Timer()`
	`java.util.TimerTask temp_task = new java.util.TimerTask(){public void run(){`
		timer!timer_timeout(1)
	`}};`
		timer_task = `temp_task`
		`` & timer & `.schedule(` & timer_task & `, ` & delay & `);`
	end
	function cancel() do
		if (not (timer_task == `null`)) do
			`` & timer_task & `.cancel();`
			`` & timer & `.purge();`
		end
	end
	statechart SoftTimer init default {
		state default {
			internal
			event m : timer?timer_start
			guard m.delay > 0
			action do
				startTimer(m.delay)
			end
			internal cancel
			event m : timer?timer_cancel
			action cancel()
		}
	}
}
datatype Byte<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@java_type "byte"
	@js_type "byte"
	@go_type "byte"
datatype Char<1>
	@type_checker "Integer"
	@c_type "char"
	@java_type "byte"
	@js_type "byte"
	@go_type "byte"
datatype Boolean<1>
	@type_checker "Boolean"
	@c_type "bool"
	@java_type "boolean"
	@js_type "boolean"
	@go_type "bool"
datatype UInt8<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@java_type "int"
	@js_type "short"
	@go_type "uint8"
datatype Int8<1>
	@type_checker "Integer"
	@c_type "int8_t"
	@java_type "int"
	@js_type "short"
	@go_type "int8"
datatype UInt16<2>
	@type_checker "Integer"
	@c_type "uint16_t"
	@java_type "int"
	@js_type "int"
	@go_type "uint16"
datatype Int16<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@java_type "int"
	@js_type "short"
	@go_type "int16"
datatype Int32<4>
	@type_checker "Integer"
	@c_type "int32_t"
	@java_type "long"
	@js_type "int"
	@go_type "int32"
datatype UInt32<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint32"
datatype Long<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint32"
datatype Int64<8>
	@type_checker "Integer"
	@c_type "int64_t"
	@java_type "long"
	@js_type "long"
	@go_type "int64"
datatype UInt64<8>
	@type_checker "Integer"
	@c_type "uint64_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint64"
datatype Integer<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@java_type "int"
	@js_type "short"
	@go_type "int16"
datatype Float<4>
	@type_checker "Real"
	@c_type "float"
	@java_type "float"
	@js_type "float"
	@go_type "float32"
datatype Double<8>
	@type_checker "Real"
	@c_type "double"
	@java_type "double"
	@js_type "double"
	@go_type "float64"
object String
	@serializable
	@c_type "char *"
	@arduino_type "String"
	@java_type "String"
	@js_type "String"
	@go_type "string"
enumeration DigitalState as UInt8 {
	LOW = 0
	HIGH = 1
}
thing fragment GeneralMsg {
	message prompt(txt : String)
	message messages(section_id : Integer, msg_type : String, msg_txt : String, value : Double)
	message reply(id : Integer, content : String)
}
thing fragment TimerMsgs {
	message timer_start(delay : Integer)
	message timer_cancel()
	@debug "false"
	message timer_timeout(id : Integer)
}
thing fragment Timer includes TimerMsgs {
	provided port timer {
		sends timer_timeout receives timer_start receives timer_cancel
	}
}
thing fragment TimerClient includes TimerMsgs {
	required port timer {
		sends timer_start sends timer_cancel receives timer_timeout
	}
}
thing TimerClientMock includes TimerClient {
}
protocol MQTT
	@serializer "JSON"
	@mqtt_broker_address "localhost"
	@mqtt_broker_port "1883"
	@mqtt_publish_topic "publish_topic"
	@mqtt_subscribe_topic "subscribe_topic"

configuration Plant_State {
	instance T1 : MQTTDriver
	instance pim : PIM
	instance timer : TimerJava
	connector T1.to_pim => pim . from_psm
	connector pim.to_psm => T1 . from_pim
	connector T1.MQTT over MQTT
	connector pim.timer => timer . timer
}
